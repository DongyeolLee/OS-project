[ORG 0x00]
[BITS 16]

SECTION .text

jmp 0x1000:START

SECTORCOUNT:	dw	0x0000		; 실행 중인 섹터 번호를 저장

TOTALSECTORCOUNT:	equ	1024 	; 가상 OS의 총 섹터 수


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, cs
	mov ds, ax
	mov ax, 0xB800				; 비디오 메모리 어드레스인 0x0B8000을 레지스터 값으로
	mov es, ax

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 화면을 모두 지우고, 속성값을 녹색으로 설정
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	%assign i	0				; i라는 변수를 지정하고 0으로 초기화
	%rep TOTALSECTORCOUNT		; TOTALSECTORCOUNT 저장된 값만큼 아래 코드를 반복
		%assign i	i + 1		; 증가

		; 현재 실행 중인 코드가 포홤된 섹터의 위치를 화면 좌표로 변환
		mov ax, 2				; 한 문자를 나타내는 바이트수 를 레지스터에 저장
		mul word [ SECTORCOUNT ]; 레지스터와 섹터 수를 곱함
		mov si, ax				; 곱한 결과를 저장

		; 계산된  결과를 비디오 메모리에 오프셋으로 삼아 세 번째 라인부터 0을 출력
		mov byte [ es: si + (160 * 2)], '0' + ( i % 10)
		add word [ SECTORCOUNT ], 1	; 섹터 수 증가

		; 마지막 섹터이면 더 수행할 섹터가 없으므로 무한 루프 수행, 그렇지 않으면 다음 섹터로
		%if i == TOTALSECTORCOUNT
			jmp $

		%else
			jmp ( 0x1000 + i * 0x20): 0x000	; 다음 섹터 오프셋으로 이동

		%endif

		times (512 - ( $ - $$) % 512)	db 0x00	; $: 현재 라인의 어드레스
												; $$: 현재 섹션(.text)의 시작 어드레스
												; 512 - ( $ - $$) % 512: 현재부터 어드레스 512 까지
												; db 0x00: 1바이트를 선언하고 값은 0x00
												; 즉, 현재 위치에서 어드레스  512까지 0x00으로 채움
	%endrep
